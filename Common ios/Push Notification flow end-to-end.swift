//
//  Push Notification flow end-to-end.swift
//  
//
//  Created by Apple on 17/12/25.
//

import Foundation

Perfect! Let’s visualize the **end-to-end Push Notification flow** including **certificate/token creation, backend, APNs, and device handling**. I’ll break it into a **diagram you can imagine or sketch** for interviews.

---

# **Push Notification End-to-End Flow Diagram (Text-Based / Interview-Ready)**

```
Step 1: Certificate / Token Creation
-----------------------------------
[Apple Developer Portal]
       │
       │ (Create APNs certificate or .p8 Auth Key)
       │
       ▼
[Certificate (.p12) or Auth Key (.p8)]
       │
       │ (used by backend to authenticate to APNs)
       ▼

Step 2: App Registers for Notifications
--------------------------------------
[App (iOS)]
   │ request permission (alert, badge, sound)
   │
   ▼
[UNUserNotificationCenter] → prompts user
   │
   ▼
[App receives device token]
   │
   ▼
[Send token to backend server]
   
Step 3: Backend Stores Device Token
-----------------------------------
[Backend Server Database]
   │
   └─ stores: userId, deviceToken, platform, lastUpdated
   │
   └─ optional metadata: categories, app version

Step 4: Backend Sends Notification to APNs
------------------------------------------
[Backend Server]
   │
   │ (HTTP/2 POST)
   │ headers: apns-topic (bundle id), authorization (JWT or certificate)
   │ payload: JSON { aps: {...}, customData }
   ▼
[APNs Server]
   │
   ├─ validate token
   ├─ queue if device offline
   ├─ route to correct device
   │
   ▼

Step 5: Device Receives Notification
-----------------------------------
[Device (iOS)]
   │
   ├─ Foreground:
   │     → userNotificationCenter(_:willPresent:withCompletionHandler:)
   │     → handle in-app (show banner, update UI)
   │
   ├─ Background / Killed:
   │     → notification appears in Notification Center
   │     → tapping triggers deep-link in app
   │
   └─ Silent notification:
         → content-available = 1
         → wakes app in background to fetch new content

Step 6: App Handles Notification Payload
----------------------------------------
[App]
   │
   ├─ Extract customData / articleId / category
   ├─ Navigate to screen or update local DB
   └─ Update badge / play sound / analytics

Step 7: Edge Cases & Feedback
-----------------------------
[APNs → Backend]
   ├─ 200 OK → notification accepted
   ├─ 400 Bad Request → invalid payload
   ├─ 410 Gone → remove token (expired/reinstalled)
[Backend] → retry logic, logging, analytics
```

---

# **Diagram Highlights / Interview Talking Points**

1. **Certificate vs Token**

   * Certificate: yearly renewal, separate dev/prod.
   * Token: one key, JWT rotates hourly, works for dev + prod, scalable.
2. **Device Token Flow**

   * Generated by APNs, sent to backend, used for targeting notifications.
3. **Payload**

   * `aps` dictionary mandatory, customData optional for deep linking.
4. **Foreground vs Background**

   * Foreground → handled in-app
   * Background → appears in Notification Center
   * Silent → triggers background fetch
5. **Error Handling**

   * APNs responses guide token removal and retries
6. **Best Practices**

   * Max payload 4KB
   * Track analytics for delivery, opens, actions
   * Handle multiple devices per user

---
                
                

Absolutely! Let’s go **step by step**, starting from **creating certificates/keys** all the way to **delivering and handling push notifications on iOS**. I’ll make this **interview- and implementation-ready**, covering both **classic certificate method** and **modern token-based approach**.

---

# **1. Prerequisites**

* Apple Developer Account (Individual/Team)
* App configured with **Bundle Identifier**
* Xcode installed
* Backend server (for sending notifications)

---

# **2. Enable Push Notifications in App**

1. Open your app target in **Xcode → Signing & Capabilities**.
2. Click **+ Capability → Push Notifications**.
3. Xcode will automatically add required entitlements:

   ```xml
   <key>aps-environment</key>
   <string>development</string>
   ```

> **Note:** `aps-environment` can be `development` or `production`. This is required for APNs to know which environment to use.

---

# **3. Create Certificates / Keys (Server Authentication)**

There are two ways:

---

### **Option 1: Certificate-Based Authentication (Older Method)**

**Step 1:** Go to Apple Developer Portal → Certificates, Identifiers & Profiles → Certificates → +

**Step 2:** Choose **Apple Push Notification service SSL (Sandbox & Production)** → select your app bundle ID.

**Step 3:** Generate a **CSR (Certificate Signing Request)** from Keychain Access:

* Open Keychain → Certificate Assistant → Request a Certificate.
* Save CSR locally.

**Step 4:** Upload CSR → download `.cer` → double-click to install in Keychain.

**Step 5:** Export **.p12 file** for backend.

* Right-click certificate in Keychain → Export → Save as `.p12`
* Set password → Backend uses `.p12` to authenticate with APNs.

---

### **Option 2: Token-Based Authentication (Preferred Modern Way)**

* Go to Apple Developer Portal → Keys → + → **APNs Auth Key**
* Key contains:

  * `Key ID`
  * `.p8 file` (downloadable once)
* Associate with your app(s)
* More secure and avoids renewing certificates annually
* Works for both **sandbox** and **production**

**Recommendation:** Use **token-based** unless legacy constraints exist.

---

# **4. App Registers for Push Notifications**

1. **Request user permission**:

```swift
import UserNotifications

UNUserNotificationCenter.current().requestAuthorization(
    options: [.alert, .sound, .badge]
) { granted, error in
    if granted {
        DispatchQueue.main.async {
            UIApplication.shared.registerForRemoteNotifications()
        }
    }
}
```

2. **Get device token**:

```swift
func application(_ application: UIApplication,
                 didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
    let tokenString = deviceToken.map { String(format: "%02.2hhx", $0) }.joined()
    sendTokenToBackend(tokenString)
}
```

* Token is **unique per device + app + environment**.
* Can change on reinstall, OS update → always send updated token to server.

---

# **5. Backend Stores Device Token**

* Map `userId → deviceToken`.
* Optional metadata:

  * Device type (iPhone/iPad)
  * App version
  * Preferences (categories)
* Database schema example:

```
Table: device_tokens
userId | deviceToken | platform | lastUpdated
```

---

# **6. Creating & Sending Notification Payload**

### **APNs HTTP/2 Endpoint**

* **Development:** `https://api.sandbox.push.apple.com:443/3/device/<deviceToken>`
* **Production:** `https://api.push.apple.com:443/3/device/<deviceToken>`

### **Headers**

* For token-based auth:

  ```
  apns-topic: <bundle_id>
  authorization: bearer <JWT token>
  apns-priority: 10
  apns-expiration: 0
  ```
* JWT token generated from `.p8` file:

  * Key ID
  * Team ID
  * Expiration: max 1 hour
* For certificate-based auth:

  * Use `.p12` SSL certificate in HTTP/2 request

---

### **Payload (JSON)**

```json
{
  "aps": {
    "alert": {
      "title": "Breaking News",
      "body": "Apple launches a new product!"
    },
    "sound": "default",
    "badge": 1,
    "category": "NEWS_CATEGORY"
  },
  "articleId": "a123",
  "customData": {
    "source": "TechCrunch"
  }
}
```

* `aps` dictionary: mandatory
* Custom fields: optional, used for deep linking or app logic
* Max payload size: 4 KB

---

# **7. APNs Delivers Notification**

* APNs validates device token.
* Routes message to the correct device.
* Queues message if device offline.
* Response codes to backend:

  * `200 OK` → queued successfully
  * `400 Bad Request` → invalid payload
  * `410 Gone` → invalid token → remove from database

---

# **8. Device Receives Notification**

### **Foreground**

* Delegate: `UNUserNotificationCenterDelegate`

```swift
func userNotificationCenter(_ center: UNUserNotificationCenter,
                            willPresent notification: UNNotification,
                            withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
    completionHandler([.banner, .sound])
}
```

### **Background / Killed**

* Notification appears in Notification Center
* Tapping triggers `userNotificationCenter(_:didReceive:withCompletionHandler:)`

---

### **Handling Payload**

```swift
func userNotificationCenter(_ center: UNUserNotificationCenter,
                            didReceive response: UNNotificationResponse,
                            withCompletionHandler completionHandler: @escaping () -> Void) {
    let userInfo = response.notification.request.content.userInfo
    if let articleId = userInfo["articleId"] as? String {
        openArticle(articleId)
    }
    completionHandler()
}
```

---

# **9. Silent Notifications (Background Updates)**

* Payload example:

```json
{
  "aps": { "content-available": 1 },
  "updateType": "newArticles"
}
```

* Wakes app in background to fetch content
* Must complete task within **30 seconds**
* iOS may throttle if abused

---

# **10. Badge & Sound**

* `badge` updates app icon
* `sound` plays notification sound
* `category` enables **custom action buttons**

---

# **11. Error Handling & Edge Cases**

| Case                           | Handling                    |
| ------------------------------ | --------------------------- |
| Token expired                  | Remove from DB              |
| APNs throttling                | Retry with backoff          |
| Offline device                 | APNs queues message         |
| Silent notifications throttled | Reduce frequency            |
| Multiple devices               | Send to all tokens per user |

---

# **12. End-to-End Flow Summary**

```
[App] → request authorization → register for push → get device token
[App] → send token to backend
[Backend] → store token, generate payload
[Backend] → send payload + token to APNs (HTTP/2)
[APNs] → validates token, queues message, delivers to device
[Device] → foreground: handle in-app
         → background: shows in Notification Center, tap opens app
```

---

# **13. Certificate vs Token Flow**

| Feature       | Certificate (.p12)              | Token (.p8)               |
| ------------- | ------------------------------- | ------------------------- |
| Expiration    | 1 year                          | None (JWT rotates hourly) |
| Easier to use | Slightly simpler for small apps | More secure, scalable     |
| Environment   | Separate dev/prod               | Same key works for both   |
| Recommended   | Legacy apps                     | Modern apps (recommended) |

---

# ✅ **Interview-Ready Key Points**

1. **Registration** → App asks permission and registers → gets device token.
2. **Backend storage** → Device token tied to user.
3. **Payload creation** → JSON `aps` dictionary + custom data.
4. **Authentication** → APNs via certificate or token.
5. **Delivery** → APNs queues and routes notifications.
6. **Device handling** → Foreground vs background.
7. **Silent notifications** → background fetch.
8. **Edge cases** → token expiry, throttling, offline devices.

---

